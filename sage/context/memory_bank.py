"""Memory bank management system for Sage projects."""

import logging
from pathlib import Path
from typing import Dict, List, Any, Optional
from datetime import datetime
from pydantic import BaseModel

from .store import ContextStore, ContextItem


class MemoryBankEntry(BaseModel):
    """Represents an entry in a project's memory bank."""
    title: str
    content: str
    category: str
    created_at: datetime
    updated_at: datetime
    source_context_id: Optional[str] = None
    relevance_score: float = 0.0


class ProjectMemoryBank:
    """Manages memory bank for a single project using Cline format."""
    
    def __init__(self, project_path: Path):
        """Initialize memory bank for a project."""
        self.project_path = project_path
        self.memory_path = project_path / "memory-bank"
        self.memory_path.mkdir(exist_ok=True)
        
        # Core memory bank files (Cline format)
        self.core_files = {
            'projectbrief.md': 'Project foundation and goals',
            'productContext.md': 'Why the project exists',
            'activeContext.md': 'Current work focus and recent changes',
            'systemPatterns.md': 'System architecture and technical decisions',
            'techContext.md': 'Technologies and development setup',
            'progress.md': 'Project status and known issues'
        }
        
        self._ensure_memory_structure()
    
    def _ensure_memory_structure(self) -> None:
        """Ensure memory bank directory structure exists."""
        # Create core files if they don't exist
        for filename, description in self.core_files.items():
            file_path = self.memory_path / filename
            if not file_path.exists():
                self._create_initial_file(file_path, filename, description)
    
    def _create_initial_file(self, file_path: Path, filename: str, description: str) -> None:
        """Create an initial memory bank file with template content."""
        templates = {
            'projectbrief.md': self._get_project_brief_template(),
            'productContext.md': self._get_product_context_template(),
            'activeContext.md': self._get_active_context_template(),
            'systemPatterns.md': self._get_system_patterns_template(),
            'techContext.md': self._get_tech_context_template(),
            'progress.md': self._get_progress_template()
        }
        
        content = templates.get(filename, f"# {filename.replace('.md', '').title()}\n\n{description}\n\n")
        
        with open(file_path, 'w', encoding='utf-8') as f:
            f.write(content)
        
        logging.info(f"Created memory bank file: {file_path}")
    
    def _get_project_brief_template(self) -> str:
        """Get template for project brief."""
        return """# Project Brief

## Project Overview
<!-- Brief description of what this project does -->

## Primary Goals
<!-- Main objectives and outcomes -->

## Key Stakeholders
<!-- Who is involved and their roles -->

## Success Criteria
<!-- How success is measured -->

---
*Generated by Sage - AI Project Context Assistant*
*Last updated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}*
"""

    def _get_product_context_template(self) -> str:
        """Get template for product context."""
        return """# Product Context

## Why This Project Exists
<!-- Business justification and market need -->

## Target Users
<!-- Who will use this and how -->

## Value Proposition
<!-- What value this provides -->

## Competitive Landscape
<!-- How this compares to alternatives -->

## Business Model
<!-- How this creates/saves value -->

---
*Generated by Sage - AI Project Context Assistant*
*Last updated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}*
"""

    def _get_active_context_template(self) -> str:
        """Get template for active context."""
        return """# Active Context

## Current Sprint/Iteration
<!-- What's being worked on right now -->

## Recent Changes
<!-- Important recent modifications -->

## Active Features
<!-- Features currently in development -->

## Known Issues
<!-- Current bugs or technical debt -->

## Next Priorities
<!-- What's coming up next -->

---
*Generated by Sage - AI Project Context Assistant*
*Last updated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}*
"""

    def _get_system_patterns_template(self) -> str:
        """Get template for system patterns."""
        return """# System Patterns

## Architecture Overview
<!-- High-level system design -->

## Design Patterns
<!-- Common patterns used throughout -->

## Data Flow
<!-- How data moves through the system -->

## Integration Patterns
<!-- How components connect -->

## Security Patterns
<!-- Security measures and patterns -->

## Performance Patterns
<!-- Performance optimization approaches -->

---
*Generated by Sage - AI Project Context Assistant*
*Last updated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}*
"""

    def _get_tech_context_template(self) -> str:
        """Get template for tech context."""
        return """# Technology Context

## Technology Stack
<!-- Languages, frameworks, libraries -->

## Development Environment
<!-- Setup requirements and tools -->

## Build System
<!-- How to build and deploy -->

## Testing Framework
<!-- Testing approach and tools -->

## Dependencies
<!-- Key external dependencies -->

## Development Workflow
<!-- How development is done -->

---
*Generated by Sage - AI Project Context Assistant*
*Last updated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}*
"""

    def _get_progress_template(self) -> str:
        """Get template for progress tracking."""
        return """# Progress Tracking

## Completed Features
<!-- What has been finished -->

## In Progress
<!-- Current work items -->

## Blockers
<!-- What's preventing progress -->

## Technical Debt
<!-- Known issues to address -->

## Performance Metrics
<!-- Key performance indicators -->

## Lessons Learned
<!-- Important insights gained -->

---
*Generated by Sage - AI Project Context Assistant*
*Last updated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}*
"""

    def update_memory_section(self, filename: str, section: str, content: str) -> None:
        """Update a specific section in a memory bank file."""
        file_path = self.memory_path / filename
        
        if not file_path.exists():
            logging.warning(f"Memory bank file not found: {filename}")
            return
        
        try:
            # Read current content
            with open(file_path, 'r', encoding='utf-8') as f:
                current_content = f.read()
            
            # Update the section
            updated_content = self._update_section_content(current_content, section, content)
            
            # Write back
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(updated_content)
            
            logging.info(f"Updated {section} in {filename}")
            
        except Exception as e:
            logging.error(f"Error updating memory bank section: {e}")
    
    def _update_section_content(self, content: str, section: str, new_content: str) -> str:
        """Update a specific section within markdown content."""
        lines = content.split('\n')
        section_start = -1
        section_end = -1
        
        # Find section boundaries
        for i, line in enumerate(lines):
            if line.strip().startswith(f'## {section}'):
                section_start = i
            elif section_start >= 0 and line.strip().startswith('## ') and i > section_start:
                section_end = i
                break
        
        if section_start >= 0:
            if section_end == -1:
                section_end = len(lines)
            
            # Replace section content
            new_lines = (lines[:section_start + 1] + 
                        [new_content] + 
                        lines[section_end:])
            
            # Update timestamp
            timestamp_line = f"*Last updated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}*"
            for i in range(len(new_lines) - 1, -1, -1):
                if new_lines[i].startswith('*Last updated:'):
                    new_lines[i] = timestamp_line
                    break
            
            return '\n'.join(new_lines)
        else:
            # Section doesn't exist, add it
            return content + f"\n\n## {section}\n{new_content}\n"
    
    def add_context_from_global_store(self, context_items: List[ContextItem]) -> None:
        """Add relevant context from global store to memory bank."""
        for context_item in context_items:
            self._integrate_context_item(context_item)
    
    def _integrate_context_item(self, context_item: ContextItem) -> None:
        """Integrate a context item into the appropriate memory bank file."""
        # Map context categories to memory bank files
        category_mapping = {
            'technologies': 'techContext.md',
            'patterns': 'systemPatterns.md',
            'solutions': 'progress.md',
            'domains': 'systemPatterns.md',
            'environments': 'techContext.md'
        }
        
        target_file = category_mapping.get(context_item.category, 'activeContext.md')
        
        # Create section name based on context
        section_name = f"{context_item.subcategory.title()} - {context_item.title}"
        
        # Add timestamp and source info
        content_with_metadata = f"""
{context_item.content}

*Source: {context_item.source}*
*Added: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}*
*Relevance Score: {context_item.relevance_score:.1f}*
"""
        
        self.update_memory_section(target_file, section_name, content_with_metadata)
        
        # Increment usage count in global store
        logging.info(f"Integrated context {context_item.id} into {target_file}")
    
    def update_tech_stack(self, technologies: List[str]) -> None:
        """Update the technology stack section."""
        tech_content = "### Detected Technologies\n\n"
        for tech in sorted(technologies):
            tech_content += f"- {tech}\n"
        
        tech_content += f"\n*Auto-detected: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}*"
        
        self.update_memory_section('techContext.md', 'Technology Stack', tech_content)
    
    def update_recent_changes(self, changes: List[str]) -> None:
        """Update recent changes section."""
        changes_content = "### Recent File Changes\n\n"
        for change in changes[-10:]:  # Keep last 10 changes
            changes_content += f"- {change}\n"
        
        changes_content += f"\n*Last updated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}*"
        
        self.update_memory_section('activeContext.md', 'Recent Changes', changes_content)
    
    def get_memory_summary(self) -> Dict[str, Any]:
        """Get a summary of the memory bank contents."""
        summary = {
            'project_path': str(self.project_path),
            'memory_files': {},
            'last_updated': None
        }
        
        latest_update = datetime.min
        
        for filename in self.core_files.keys():
            file_path = self.memory_path / filename
            if file_path.exists():
                stat = file_path.stat()
                modified_time = datetime.fromtimestamp(stat.st_mtime)
                
                summary['memory_files'][filename] = {
                    'exists': True,
                    'size': stat.st_size,
                    'modified': modified_time.isoformat()
                }
                
                if modified_time > latest_update:
                    latest_update = modified_time
            else:
                summary['memory_files'][filename] = {'exists': False}
        
        if latest_update != datetime.min:
            summary['last_updated'] = latest_update.isoformat()
        
        return summary
    
    def cleanup_old_entries(self, days_old: int = 90) -> None:
        """Clean up old entries from memory bank files."""
        cutoff_date = datetime.now().timestamp() - (days_old * 24 * 3600)
        
        for filename in self.core_files.keys():
            file_path = self.memory_path / filename
            if file_path.exists():
                stat = file_path.stat()
                if stat.st_mtime < cutoff_date:
                    logging.info(f"Memory bank file {filename} is old but preserved for continuity")


class MemoryBankManager:
    """Manages memory banks for multiple projects."""
    
    def __init__(self, context_store: ContextStore):
        """Initialize memory bank manager."""
        self.context_store = context_store
        self.memory_banks: Dict[str, ProjectMemoryBank] = {}
    
    def get_memory_bank(self, project_path: Path) -> ProjectMemoryBank:
        """Get or create memory bank for a project."""
        project_key = str(project_path)
        
        if project_key not in self.memory_banks:
            self.memory_banks[project_key] = ProjectMemoryBank(project_path)
        
        return self.memory_banks[project_key]
    
    def update_project_context(self, project_path: Path, 
                             technologies: List[str],
                             recent_changes: List[str]) -> None:
        """Update project context with new information."""
        memory_bank = self.get_memory_bank(project_path)
        
        # Update technology stack
        memory_bank.update_tech_stack(technologies)
        
        # Update recent changes
        memory_bank.update_recent_changes(recent_changes)
        
        # Find and add relevant context from global store
        relevant_contexts = []
        for tech in technologies:
            contexts = self.context_store.get_contexts_by_technology(tech, limit=3)
            relevant_contexts.extend(contexts)
        
        if relevant_contexts:
            memory_bank.add_context_from_global_store(relevant_contexts)
        
        logging.info(f"Updated memory bank for project: {project_path}")
    
    def get_all_memory_summaries(self) -> Dict[str, Any]:
        """Get summaries of all memory banks."""
        summaries = {}
        for project_key, memory_bank in self.memory_banks.items():
            summaries[project_key] = memory_bank.get_memory_summary()
        return summaries